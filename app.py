# -*- coding: utf-8 -*-
"""ì›Œí„°ë§ˆí‚¹ì‹œìŠ¤í…œ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17EOpDL6hwJ6f3G_-7bpUspm-1-XcgL_w
"""

import gradio as gr
import numpy as np
import cv2
import torch
import torch.nn as nn
import torch.nn.functional as F
from PIL import Image
import io
import base64
import json
import time
from typing import Tuple, Optional
import matplotlib.pyplot as plt
import tempfile
import os

# ===== ê²½ëŸ‰í™” CNN ì›Œí„°ë§ˆí‚¹ ëª¨ë¸ =====
class MobileWatermarkEncoder(nn.Module):
    """ëª¨ë°”ì¼ ìµœì í™” ì›Œí„°ë§ˆí¬ ì¸ì½”ë”"""
    def __init__(self, watermark_size=32):
        super().__init__()
        self.watermark_size = watermark_size

        # ê²½ëŸ‰í™” ì¸ì½”ë” (MobileNet ìŠ¤íƒ€ì¼)
        self.encoder = nn.Sequential(
            # ì´ˆê¸° íŠ¹ì§• ì¶”ì¶œ
            nn.Conv2d(3, 32, 3, padding=1),
            nn.BatchNorm2d(32),
            nn.ReLU(inplace=True),

            # Depthwise Separable Convolution
            nn.Conv2d(32, 32, 3, padding=1, groups=32),  # Depthwise
            nn.Conv2d(32, 64, 1),  # Pointwise
            nn.BatchNorm2d(64),
            nn.ReLU(inplace=True),

            nn.Conv2d(64, 64, 3, padding=1, groups=64),
            nn.Conv2d(64, 128, 1),
            nn.BatchNorm2d(128),
            nn.ReLU(inplace=True),

            # ì¶œë ¥ì¸µ
            nn.Conv2d(128, 3, 3, padding=1),
            nn.Tanh()
        )

        # ì›Œí„°ë§ˆí¬ ì„ë² ë”© ê°•ë„ ì¡°ì ˆ
        self.alpha = nn.Parameter(torch.tensor(0.1))

    def forward(self, image, watermark_pattern):
        # ì›Œí„°ë§ˆí¬ íŒ¨í„´ì„ ì´ë¯¸ì§€ í¬ê¸°ì— ë§ê²Œ í™•ì¥
        h, w = image.shape[2], image.shape[3]
        watermark = F.interpolate(watermark_pattern, size=(h, w), mode='bilinear')

        # ì›Œí„°ë§ˆí¬ ì„ë² ë”©
        watermark_noise = self.encoder(image)
        watermarked = image + self.alpha * watermark_noise * watermark

        return torch.clamp(watermarked, 0, 1)

class MobileWatermarkDecoder(nn.Module):
    """ëª¨ë°”ì¼ ìµœì í™” ì›Œí„°ë§ˆí¬ ë””ì½”ë”"""
    def __init__(self, watermark_size=32):
        super().__init__()
        self.watermark_size = watermark_size

        self.decoder = nn.Sequential(
            nn.Conv2d(3, 32, 3, padding=1),
            nn.ReLU(inplace=True),
            nn.Conv2d(32, 64, 3, padding=1),
            nn.ReLU(inplace=True),
            nn.AdaptiveAvgPool2d((watermark_size, watermark_size)),
            nn.Conv2d(64, 1, 1),
            nn.Sigmoid()
        )

    def forward(self, image):
        return self.decoder(image)

# ===== ì›Œí„°ë§ˆí‚¹ ì‹œìŠ¤í…œ í´ë˜ìŠ¤ =====
class MobileWatermarkingSystem:
    def __init__(self):
        self.encoder = MobileWatermarkEncoder()
        self.decoder = MobileWatermarkDecoder()
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        # ëª¨ë¸ì„ deviceë¡œ ì´ë™
        self.encoder.to(self.device)
        self.decoder.to(self.device)

        # ê°„ë‹¨í•œ í›ˆë ¨ìš© ë”ë¯¸ ë°ì´í„°ë¡œ ì´ˆê¸°í™”
        self._initialize_models()

    def _initialize_models(self):
        """ëª¨ë¸ ì´ˆê¸°í™” (ì‹¤ì œë¡œëŠ” ì‚¬ì „ í›ˆë ¨ëœ ê°€ì¤‘ì¹˜ ë¡œë“œ)"""
        # ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ì´ˆê¸°í™”ë§Œ ìˆ˜í–‰
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ì „ í›ˆë ¨ëœ ëª¨ë¸ ë¡œë“œ
        pass

    def generate_watermark_pattern(self, user_id: str, timestamp: str) -> torch.Tensor:
        """ì‚¬ìš©ì IDì™€ íƒ€ì„ìŠ¤íƒ¬í”„ë¡œ ê³ ìœ  ì›Œí„°ë§ˆí¬ íŒ¨í„´ ìƒì„±"""
        # ê°„ë‹¨í•œ íŒ¨í„´ ìƒì„± (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ë°©ë²• ì‚¬ìš©)
        seed = hash(user_id + timestamp) % 10000
        torch.manual_seed(seed)
        pattern = torch.randn(1, 1, 32, 32)
        return torch.sigmoid(pattern)

    def embed_watermark(self, image: np.ndarray, user_id: str) -> Tuple[np.ndarray, dict]:
        """ì´ë¯¸ì§€ì— ì›Œí„°ë§ˆí¬ ì‚½ì…"""
        start_time = time.time()

        # ì´ë¯¸ì§€ ì „ì²˜ë¦¬
        if len(image.shape) == 3:
            image_tensor = torch.from_numpy(image.transpose(2, 0, 1)).float() / 255.0
        else:
            image_tensor = torch.from_numpy(image).float() / 255.0
            image_tensor = image_tensor.unsqueeze(0).repeat(3, 1, 1)

        image_tensor = image_tensor.unsqueeze(0).to(self.device)

        # ì›Œí„°ë§ˆí¬ íŒ¨í„´ ìƒì„±
        timestamp = str(int(time.time()))
        watermark_pattern = self.generate_watermark_pattern(user_id, timestamp)
        watermark_pattern = watermark_pattern.to(self.device)

        # ì›Œí„°ë§ˆí¬ ì‚½ì…
        with torch.no_grad():
            watermarked_tensor = self.encoder(image_tensor, watermark_pattern)

        # í›„ì²˜ë¦¬
        watermarked_image = watermarked_tensor.squeeze(0).cpu().numpy()
        watermarked_image = (watermarked_image.transpose(1, 2, 0) * 255).astype(np.uint8)

        processing_time = time.time() - start_time

        # ë©”íƒ€ë°ì´í„°
        metadata = {
            'user_id': user_id,
            'timestamp': timestamp,
            'processing_time': processing_time,
            'image_size': image.shape,
            'watermark_strength': float(self.encoder.alpha.item())
        }

        return watermarked_image, metadata

    def extract_watermark(self, image: np.ndarray) -> Tuple[np.ndarray, float]:
        """ì´ë¯¸ì§€ì—ì„œ ì›Œí„°ë§ˆí¬ ì¶”ì¶œ ë° ê²€ì¦"""
        start_time = time.time()

        # ì´ë¯¸ì§€ ì „ì²˜ë¦¬
        if len(image.shape) == 3:
            image_tensor = torch.from_numpy(image.transpose(2, 0, 1)).float() / 255.0
        else:
            image_tensor = torch.from_numpy(image).float() / 255.0
            image_tensor = image_tensor.unsqueeze(0).repeat(3, 1, 1)

        image_tensor = image_tensor.unsqueeze(0).to(self.device)

        # ì›Œí„°ë§ˆí¬ ì¶”ì¶œ
        with torch.no_grad():
            extracted_watermark = self.decoder(image_tensor)

        # í›„ì²˜ë¦¬
        watermark_array = extracted_watermark.squeeze().cpu().numpy()
        confidence = np.mean(watermark_array)  # ê°„ë‹¨í•œ ì‹ ë¢°ë„ ê³„ì‚°

        processing_time = time.time() - start_time

        return watermark_array, confidence

    def verify_watermark(self, original_metadata: dict, extracted_confidence: float) -> dict:
        """ì›Œí„°ë§ˆí¬ ê²€ì¦"""
        threshold = 0.3  # ê²€ì¦ ì„ê³„ê°’
        is_valid = bool(extracted_confidence > threshold)  # bool() ëª…ì‹œì  ë³€í™˜

        return {
            'is_valid': is_valid,
            'confidence': float(extracted_confidence),  # float() ëª…ì‹œì  ë³€í™˜
            'threshold': float(threshold),
            'original_metadata': original_metadata
        }

# ===== ì „ì—­ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ =====
watermarking_system = MobileWatermarkingSystem()

# ===== Gradio ì¸í„°í˜ì´ìŠ¤ í•¨ìˆ˜ë“¤ =====
def embed_watermark_interface(image, user_id, output_format):
    """ì›Œí„°ë§ˆí¬ ì‚½ì… ì¸í„°í˜ì´ìŠ¤"""
    if image is None:
        return None, "ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.", None, None

    if not user_id.strip():
        return None, "ì‚¬ìš©ì IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.", None, None

    try:
        # ì›Œí„°ë§ˆí¬ ì‚½ì…
        watermarked_image, metadata = watermarking_system.embed_watermark(image, user_id)

        # ë©”íƒ€ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ë³€í™˜
        metadata_json = json.dumps(metadata, indent=2)

        # ë‹¤ìš´ë¡œë“œìš© íŒŒì¼ ìƒì„±
        download_file = create_download_file(watermarked_image, user_id, metadata, output_format)

        # ê²°ê³¼ ë©”ì‹œì§€
        result_msg = f"""
âœ… ì›Œí„°ë§ˆí¬ ì‚½ì… ì™„ë£Œ!
ğŸ“Š ì²˜ë¦¬ ì‹œê°„: {metadata['processing_time']:.3f}ì´ˆ
ğŸ“ ì´ë¯¸ì§€ í¬ê¸°: {metadata['image_size']}
ğŸ’ª ì›Œí„°ë§ˆí¬ ê°•ë„: {metadata['watermark_strength']:.3f}
ğŸ†” ì‚¬ìš©ì ID: {metadata['user_id']}
â° íƒ€ì„ìŠ¤íƒ¬í”„: {metadata['timestamp']}
ğŸ“„ í¬ë§·: {output_format.upper()}
        """

        return watermarked_image, result_msg, metadata_json, download_file

    except Exception as e:
        return None, f"ì˜¤ë¥˜ ë°œìƒ: {str(e)}", None, None

def create_download_file(image, user_id, metadata, output_format):
    """ë‹¤ìš´ë¡œë“œìš© íŒŒì¼ ìƒì„±"""
    try:
        # PIL Imageë¡œ ë³€í™˜
        if isinstance(image, np.ndarray):
            pil_image = Image.fromarray(image)
        else:
            pil_image = image

        # íŒŒì¼ëª… ìƒì„±
        timestamp = metadata['timestamp']
        filename = f"watermarked_{user_id}_{timestamp}.{output_format.lower()}"

        # ì„ì‹œ íŒŒì¼ ìƒì„±
        temp_dir = tempfile.mkdtemp()
        temp_path = os.path.join(temp_dir, filename)

        if output_format.lower() == 'jpg':
            # JPGëŠ” RGB ëª¨ë“œ í•„ìš”
            if pil_image.mode in ('RGBA', 'LA', 'P'):
                # íˆ¬ëª…ë„ê°€ ìˆëŠ” ê²½ìš° í°ìƒ‰ ë°°ê²½ê³¼ í•©ì„±
                background = Image.new('RGB', pil_image.size, (255, 255, 255))
                if pil_image.mode == 'P':
                    pil_image = pil_image.convert('RGBA')
                background.paste(pil_image, mask=pil_image.split()[-1] if pil_image.mode == 'RGBA' else None)
                pil_image = background

            pil_image.save(temp_path, format='JPEG', quality=95, optimize=True)

        elif output_format.lower() == 'png':
            # PNG ë©”íƒ€ë°ì´í„°
            pnginfo = Image.PngImagePlugin.PngInfo()
            pnginfo.add_text("User_ID", user_id)
            pnginfo.add_text("Timestamp", timestamp)
            pnginfo.add_text("Watermark_Strength", str(metadata['watermark_strength']))
            pnginfo.add_text("Software", "Mobile Watermarking System")

            pil_image.save(temp_path, format='PNG', pnginfo=pnginfo, optimize=True)

        return temp_path

    except Exception as e:
        print(f"ë‹¤ìš´ë¡œë“œ íŒŒì¼ ìƒì„± ì˜¤ë¥˜: {e}")
        return None

def extract_watermark_interface(image, metadata_json):
    """ì›Œí„°ë§ˆí¬ ì¶”ì¶œ ë° ê²€ì¦ ì¸í„°í˜ì´ìŠ¤"""
    if image is None:
        return None, "ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.", None

    try:
        # ì›Œí„°ë§ˆí¬ ì¶”ì¶œ
        watermark_pattern, confidence = watermarking_system.extract_watermark(image)

        # ì›Œí„°ë§ˆí¬ íŒ¨í„´ ì‹œê°í™” (ì œëª©ë§Œ ì˜ì–´, í°íŠ¸ ì„¤ì •)
        plt.figure(figsize=(6, 6))
        plt.rcParams['font.family'] = 'DejaVu Sans'  # ì˜ì–´ í°íŠ¸ ì„¤ì •
        plt.rcParams['font.size'] = 10

        plt.imshow(watermark_pattern, cmap='viridis')
        plt.title(f'Extracted Watermark Pattern (Confidence: {confidence:.3f})',
                 fontsize=12, fontweight='bold')
        plt.colorbar(label='Pattern Intensity')
        plt.axis('off')

        # ì„ì‹œ íŒŒì¼ë¡œ ì €ì¥
        watermark_viz = plt.gcf()

        # ì‹ ë¢°ë„ë³„ í•´ì„ ë©”ì‹œì§€ ìƒì„± (í•œê¸€)
        def get_confidence_interpretation(conf):
            if conf >= 0.8:
                return {
                    'level': 'ë†’ìŒ',
                    'emoji': 'âœ…',
                    'message': 'ì›Œí„°ë§ˆí¬ê°€ ëª…í™•íˆ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.',
                    'detail': 'ì´ ì´ë¯¸ì§€ëŠ” ì›Œí„°ë§ˆí¬ê°€ ì‚½ì…ëœ ì´ë¯¸ì§€ë¡œ íŒë‹¨ë©ë‹ˆë‹¤.',
                    'color': 'ğŸŸ¢'
                }
            elif conf >= 0.6:
                return {
                    'level': 'ë³´í†µ',
                    'emoji': 'âš ï¸',
                    'message': 'ì›Œí„°ë§ˆí¬ íŒ¨í„´ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.',
                    'detail': 'ì›Œí„°ë§ˆí¬ê°€ ìˆì„ ê°€ëŠ¥ì„±ì´ ë†’ì§€ë§Œ ì¶”ê°€ ê²€ì¦ì´ ê¶Œì¥ë©ë‹ˆë‹¤.',
                    'color': 'ğŸŸ¡'
                }
            elif conf >= 0.3:
                return {
                    'level': 'ë‚®ìŒ',
                    'emoji': 'â“',
                    'message': 'ì•½í•œ ì›Œí„°ë§ˆí¬ ì‹ í˜¸ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.',
                    'detail': 'ì›Œí„°ë§ˆí¬ê°€ ìˆì„ ìˆ˜ ìˆì§€ë§Œ ë…¸ì´ì¦ˆì¼ ê°€ëŠ¥ì„±ë„ ìˆìŠµë‹ˆë‹¤.',
                    'color': 'ğŸŸ '
                }
            else:
                return {
                    'level': 'ë§¤ìš° ë‚®ìŒ',
                    'emoji': 'âŒ',
                    'message': 'ì›Œí„°ë§ˆí¬ê°€ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
                    'detail': 'ì´ ì´ë¯¸ì§€ì—ëŠ” ì›Œí„°ë§ˆí¬ê°€ ì—†ê±°ë‚˜ ì†ìƒë˜ì—ˆì„ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤.',
                    'color': 'ğŸ”´'
                }

        confidence_info = get_confidence_interpretation(confidence)

        # ê²€ì¦ ìˆ˜í–‰
        verification_result = None
        if metadata_json and metadata_json.strip():
            try:
                original_metadata = json.loads(metadata_json)
                verification_result = watermarking_system.verify_watermark(
                    original_metadata, confidence
                )

                # JSON ì§ë ¬í™” ê°€ëŠ¥í•˜ë„ë¡ ë°ì´í„° íƒ€ì… ë³´ì¥
                verification_result = {
                    'is_valid': bool(verification_result['is_valid']),
                    'confidence': float(verification_result['confidence']),
                    'threshold': float(verification_result['threshold']),
                    'original_metadata': verification_result['original_metadata'],
                    'confidence_level': confidence_info['level'],
                    'interpretation': confidence_info['message']
                }

            except json.JSONDecodeError as e:
                verification_result = {
                    'error': f'ë©”íƒ€ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜: {str(e)}',
                    'confidence': float(confidence),
                    'threshold': 0.3,
                    'confidence_level': confidence_info['level'],
                    'interpretation': confidence_info['message']
                }
            except Exception as e:
                verification_result = {
                    'error': f'ê²€ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}',
                    'confidence': float(confidence),
                    'threshold': 0.3,
                    'confidence_level': confidence_info['level'],
                    'interpretation': confidence_info['message']
                }

        # ê²°ê³¼ ë©”ì‹œì§€ (í•œê¸€)
        result_msg = f"""
ğŸ” ì›Œí„°ë§ˆí¬ ì¶”ì¶œ ì™„ë£Œ!
ğŸ“Š ì‹ ë¢°ë„: {confidence:.3f}
{confidence_info['color']} ì‹ ë¢°ë„ ìˆ˜ì¤€: {confidence_info['level']}

{confidence_info['emoji']} {confidence_info['message']}
ğŸ’¡ {confidence_info['detail']}
        """

        if verification_result and 'error' not in verification_result:
            status = "âœ… ìœ íš¨" if verification_result['is_valid'] else "âŒ ë¬´íš¨"
            result_msg += f"""

ğŸ›¡ï¸ ê²€ì¦ ê²°ê³¼: {status}
ğŸ“ ì„ê³„ê°’: {verification_result['threshold']}
            """

            # ë©”íƒ€ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš° ì¶”ê°€ ì •ë³´
            if 'original_metadata' in verification_result:
                orig_meta = verification_result['original_metadata']
                result_msg += f"""
ğŸ†” ì›ë³¸ ì‚¬ìš©ì: {orig_meta.get('user_id', 'N/A')}
â° ìƒì„± ì‹œê°„: {orig_meta.get('timestamp', 'N/A')}
ğŸ’ª ì›ë³¸ ê°•ë„: {orig_meta.get('watermark_strength', 'N/A')}
            """
        elif verification_result and 'error' in verification_result:
            result_msg += f"""

âš ï¸ ê²€ì¦ ì˜¤ë¥˜: {verification_result['error']}
            """

        # ì¶”ê°€ í•´ì„ ê°€ì´ë“œ (í•œê¸€)
        result_msg += f"""

ğŸ“– í•´ì„ ê°€ì´ë“œ:
â€¢ 0.8 ì´ìƒ: ì›Œí„°ë§ˆí¬ í™•ì‹¤íˆ ì¡´ì¬ âœ…
â€¢ 0.6~0.8: ì›Œí„°ë§ˆí¬ ì¡´ì¬ ê°€ëŠ¥ì„± ë†’ìŒ âš ï¸
â€¢ 0.3~0.6: ì›Œí„°ë§ˆí¬ ì¡´ì¬ ë¶ˆí™•ì‹¤ â“
â€¢ 0.3 ë¯¸ë§Œ: ì›Œí„°ë§ˆí¬ ì—†ìŒ âŒ
        """

        plt.close()

        # JSON ì§ë ¬í™” ê²€ì¦
        verification_json = None
        if verification_result:
            try:
                verification_json = json.dumps(verification_result, indent=2, ensure_ascii=False)
            except Exception as e:
                verification_json = json.dumps({
                    'error': f'JSON ì§ë ¬í™” ì˜¤ë¥˜: {str(e)}',
                    'confidence': float(confidence),
                    'confidence_level': confidence_info['level'],
                    'interpretation': confidence_info['message']
                }, indent=2, ensure_ascii=False)

        return watermark_viz, result_msg, verification_json

    except Exception as e:
        plt.close()
        return None, f"ì˜¤ë¥˜ ë°œìƒ: {str(e)}", json.dumps({
            'error': f'ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜: {str(e)}'
        }, indent=2, ensure_ascii=False)

def compare_images(original, watermarked):
    """ì›ë³¸ê³¼ ì›Œí„°ë§ˆí¬ëœ ì´ë¯¸ì§€ ë¹„êµ"""
    if original is None or watermarked is None:
        return None, "ë‘ ì´ë¯¸ì§€ê°€ ëª¨ë‘ í•„ìš”í•©ë‹ˆë‹¤."

    try:
        # ì´ë¯¸ì§€ í¬ê¸° ë§ì¶”ê¸°
        h1, w1 = original.shape[:2]
        h2, w2 = watermarked.shape[:2]

        if (h1, w1) != (h2, w2):
            watermarked = cv2.resize(watermarked, (w1, h1))

        # PSNR ê³„ì‚°
        mse = np.mean((original.astype(float) - watermarked.astype(float)) ** 2)
        if mse == 0:
            psnr = float('inf')
        else:
            psnr = 20 * np.log10(255.0 / np.sqrt(mse))

        # ì°¨ì´ ì´ë¯¸ì§€ ìƒì„±
        diff = np.abs(original.astype(float) - watermarked.astype(float))
        diff = (diff / diff.max() * 255).astype(np.uint8)

        # ì‹œê°í™” (ì œëª©ë§Œ ì˜ì–´ë¡œ, í°íŠ¸ ì„¤ì •)
        plt.rcParams['font.family'] = 'DejaVu Sans'
        plt.rcParams['font.size'] = 10

        fig, axes = plt.subplots(1, 3, figsize=(15, 5))

        axes[0].imshow(original)
        axes[0].set_title('Original Image', fontweight='bold')
        axes[0].axis('off')

        axes[1].imshow(watermarked)
        axes[1].set_title('Watermarked Image', fontweight='bold')
        axes[1].axis('off')

        axes[2].imshow(diff, cmap='hot')
        axes[2].set_title(f'Difference (PSNR: {psnr:.2f}dB)', fontweight='bold')
        axes[2].axis('off')

        plt.tight_layout()

        result_msg = f"""
ğŸ“Š ì´ë¯¸ì§€ í’ˆì§ˆ ë¶„ì„:
- PSNR: {psnr:.2f} dB
- MSE: {mse:.2f}
- ì´ë¯¸ì§€ í¬ê¸°: {original.shape}
        """

        comparison_fig = plt.gcf()
        plt.close()

        return comparison_fig, result_msg

    except Exception as e:
        return None, f"ì˜¤ë¥˜ ë°œìƒ: {str(e)}"

# ===== Gradio ì¸í„°í˜ì´ìŠ¤ êµ¬ì„± =====
def create_gradio_interface():
    """Gradio ì¸í„°í˜ì´ìŠ¤ ìƒì„±"""

    with gr.Blocks(title="ëª¨ë°”ì¼ ì›Œí„°ë§ˆí‚¹ ì‹¤í—˜ ì‹œìŠ¤í…œ", theme=gr.themes.Soft()) as demo:
        gr.Markdown("""
        # ğŸ“± ëª¨ë°”ì¼ í™˜ê²½ CNN ê¸°ë°˜ ì›Œí„°ë§ˆí‚¹ ì‹œìŠ¤í…œ

        ì´ ì‹œìŠ¤í…œì€ ëª¨ë°”ì¼ í™˜ê²½ì— ìµœì í™”ëœ ì‹¤ì‹œê°„ ì´ë¯¸ì§€ ì›Œí„°ë§ˆí‚¹ ê¸°ìˆ ì„ ì‹¤í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

        ## ğŸ”¬ ì£¼ìš” ê¸°ëŠ¥
        - **ì‹¤ì‹œê°„ ì›Œí„°ë§ˆí¬ ì‚½ì…**: ê²½ëŸ‰í™”ëœ CNN ëª¨ë¸ë¡œ ë¹ ë¥¸ ì²˜ë¦¬
        - **ì ì‘í˜• í•´ìƒë„ ì§€ì›**: ë‹¤ì–‘í•œ ì´ë¯¸ì§€ í¬ê¸°ì— ìë™ ì ì‘
        - **ì›Œí„°ë§ˆí¬ ê²€ì¦**: ì‚½ì…ëœ ì›Œí„°ë§ˆí¬ì˜ ì¶”ì¶œ ë° ê²€ì¦
        - **í’ˆì§ˆ ë¶„ì„**: ì›ë³¸ ëŒ€ë¹„ í™”ì§ˆ ë³€í™” ì¸¡ì •
        """)

        with gr.Tabs():
            # íƒ­ 1: ì›Œí„°ë§ˆí¬ ì‚½ì…
            with gr.Tab("ğŸ”’ ì›Œí„°ë§ˆí¬ ì‚½ì…"):
                with gr.Row():
                    with gr.Column():
                        embed_input_image = gr.Image(
                            label="ğŸ“· ì›ë³¸ ì´ë¯¸ì§€ ì—…ë¡œë“œ",
                            type="numpy"
                        )
                        embed_user_id = gr.Textbox(
                            label="ğŸ†” ì‚¬ìš©ì ID",
                            placeholder="ì˜ˆ: user123",
                            value="demo_user"
                        )
                        output_format = gr.Radio(
                            label="ğŸ“„ ì¶œë ¥ í¬ë§·",
                            choices=["PNG", "JPG"],
                            value="PNG"
                        )
                        embed_btn = gr.Button("ğŸ”’ ì›Œí„°ë§ˆí¬ ì‚½ì…", variant="primary")

                    with gr.Column():
                        embed_output_image = gr.Image(label="ğŸ” ì›Œí„°ë§ˆí¬ëœ ì´ë¯¸ì§€")
                        embed_result_text = gr.Textbox(
                            label="ğŸ“Š ì²˜ë¦¬ ê²°ê³¼",
                            lines=8,
                            interactive=False
                        )
                        download_btn = gr.DownloadButton(
                            label="ğŸ’¾ ì›Œí„°ë§ˆí¬ëœ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ",
                            variant="secondary"
                        )

                embed_metadata = gr.JSON(label="ğŸ“‹ ë©”íƒ€ë°ì´í„°", visible=False)

                embed_btn.click(
                    fn=embed_watermark_interface,
                    inputs=[embed_input_image, embed_user_id, output_format],
                    outputs=[embed_output_image, embed_result_text, embed_metadata, download_btn]
                )

            # íƒ­ 2: ì›Œí„°ë§ˆí¬ ì¶”ì¶œ ë° ê²€ì¦
            with gr.Tab("ğŸ” ì›Œí„°ë§ˆí¬ ê²€ì¦"):
                with gr.Row():
                    with gr.Column():
                        extract_input_image = gr.Image(
                            label="ğŸ” ì›Œí„°ë§ˆí¬ëœ ì´ë¯¸ì§€ ì—…ë¡œë“œ",
                            type="numpy"
                        )
                        extract_metadata = gr.Textbox(
                            label="ğŸ“‹ ì›ë³¸ ë©”íƒ€ë°ì´í„° (ì„ íƒì‚¬í•­)",
                            placeholder="ì›Œí„°ë§ˆí¬ ì‚½ì… ì‹œ ìƒì„±ëœ ë©”íƒ€ë°ì´í„°ë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”",
                            lines=5
                        )
                        extract_btn = gr.Button("ğŸ” ì›Œí„°ë§ˆí¬ ì¶”ì¶œ", variant="primary")

                    with gr.Column():
                        extract_output_viz = gr.Plot(label="ğŸ¨ ì¶”ì¶œëœ ì›Œí„°ë§ˆí¬ íŒ¨í„´")
                        extract_result_text = gr.Textbox(
                            label="ğŸ“Š ì¶”ì¶œ ê²°ê³¼",
                            lines=5,
                            interactive=False
                        )

                extract_verification = gr.JSON(label="ğŸ›¡ï¸ ê²€ì¦ ê²°ê³¼", visible=True)

                extract_btn.click(
                    fn=extract_watermark_interface,
                    inputs=[extract_input_image, extract_metadata],
                    outputs=[extract_output_viz, extract_result_text, extract_verification]
                )

            # íƒ­ 3: ì´ë¯¸ì§€ í’ˆì§ˆ ë¹„êµ
            with gr.Tab("ğŸ“Š í’ˆì§ˆ ë¶„ì„"):
                with gr.Row():
                    with gr.Column():
                        compare_original = gr.Image(
                            label="ğŸ“· ì›ë³¸ ì´ë¯¸ì§€",
                            type="numpy"
                        )
                        compare_watermarked = gr.Image(
                            label="ğŸ” ì›Œí„°ë§ˆí¬ëœ ì´ë¯¸ì§€",
                            type="numpy"
                        )
                        compare_btn = gr.Button("ğŸ“Š í’ˆì§ˆ ë¹„êµ", variant="primary")

                    with gr.Column():
                        compare_output_plot = gr.Plot(label="ğŸ”¬ ë¹„êµ ë¶„ì„ ê²°ê³¼")
                        compare_result_text = gr.Textbox(
                            label="ğŸ“ˆ ë¶„ì„ ê²°ê³¼",
                            lines=6,
                            interactive=False
                        )

                compare_btn.click(
                    fn=compare_images,
                    inputs=[compare_original, compare_watermarked],
                    outputs=[compare_output_plot, compare_result_text]
                )

            # íƒ­ 4: ì‹œìŠ¤í…œ ì •ë³´
            with gr.Tab("â„¹ï¸ ì‹œìŠ¤í…œ ì •ë³´"):
                gr.Markdown(f"""
                ## ğŸ”§ ì‹œìŠ¤í…œ ì‚¬ì–‘

                - **ë””ë°”ì´ìŠ¤**: {watermarking_system.device}
                - **CNN ì•„í‚¤í…ì²˜**: MobileNet ê¸°ë°˜ ê²½ëŸ‰í™” ëª¨ë¸
                - **ì›Œí„°ë§ˆí¬ í¬ê¸°**: 32x32 í”½ì…€
                - **ì§€ì› í¬ë§·**: JPG, PNG, BMP

                ## ğŸ“ˆ ì„±ëŠ¥ íŠ¹ì§•

                - **ì²˜ë¦¬ ì†ë„**: < 1ì´ˆ (ëª©í‘œ)
                - **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ëª¨ë°”ì¼ ìµœì í™”
                - **í•´ìƒë„ ì ì‘**: ë™ì  í¬ê¸° ì¡°ì ˆ
                - **ê²¬ê³ ì„±**: ì••ì¶•/ë³€í™˜ ê³µê²© ì €í•­

                ## ğŸ¯ ì‚¬ìš© ë°©ë²•

                1. **ì›Œí„°ë§ˆí¬ ì‚½ì…**: ì›ë³¸ ì´ë¯¸ì§€ì™€ ì‚¬ìš©ì ID ì…ë ¥
                2. **ì›Œí„°ë§ˆí¬ ê²€ì¦**: ì˜ì‹¬ë˜ëŠ” ì´ë¯¸ì§€ ì—…ë¡œë“œ í›„ ì¶”ì¶œ
                3. **í’ˆì§ˆ ë¶„ì„**: ì›ë³¸ê³¼ ì›Œí„°ë§ˆí¬ëœ ì´ë¯¸ì§€ ë¹„êµ

                ## âš ï¸ ì£¼ì˜ì‚¬í•­

                - ì´ëŠ” ì‹¤í—˜ìš© í”„ë¡œí† íƒ€ì…ì…ë‹ˆë‹¤
                - ì‹¤ì œ ìƒìš© í™˜ê²½ì—ì„œëŠ” ì¶”ê°€ ìµœì í™”ê°€ í•„ìš”í•©ë‹ˆë‹¤
                - ë³´ì•ˆ ê°•í™”ë¥¼ ìœ„í•´ ë” ë³µì¡í•œ ì•”í˜¸í™” ê¸°ë²• ì ìš© ê¶Œì¥
                """)

        # ì—°ê²° ê¸°ëŠ¥: ì›Œí„°ë§ˆí¬ ì‚½ì… ê²°ê³¼ë¥¼ ê²€ì¦ íƒ­ìœ¼ë¡œ ì „ë‹¬
        embed_output_image.change(
            fn=lambda x: x,
            inputs=[embed_output_image],
            outputs=[extract_input_image]
        )

        embed_metadata.change(
            fn=lambda x: json.dumps(x, indent=2) if x else "",
            inputs=[embed_metadata],
            outputs=[extract_metadata]
        )

        # ì—°ê²° ê¸°ëŠ¥: ë¹„êµ ë¶„ì„ì„ ìœ„í•œ ì´ë¯¸ì§€ ì „ë‹¬
        embed_input_image.change(
            fn=lambda x: x,
            inputs=[embed_input_image],
            outputs=[compare_original]
        )

        embed_output_image.change(
            fn=lambda x: x,
            inputs=[embed_output_image],
            outputs=[compare_watermarked]
        )

    return demo

# ===== ë©”ì¸ ì‹¤í–‰ =====
if __name__ == "__main__":
    # Gradio ì¸í„°í˜ì´ìŠ¤ ìƒì„± ë° ì‹¤í–‰
    demo = create_gradio_interface()

    # Colab í™˜ê²½ì—ì„œ ì‹¤í–‰
    demo.launch(
        share=True,  # ê³µê°œ ë§í¬ ìƒì„±
        debug=True,  # ë””ë²„ê·¸ ëª¨ë“œ
        server_name="0.0.0.0",  # ëª¨ë“  IPì—ì„œ ì ‘ê·¼ ê°€ëŠ¥
        server_port=7860  # í¬íŠ¸ ì§€ì •
    )